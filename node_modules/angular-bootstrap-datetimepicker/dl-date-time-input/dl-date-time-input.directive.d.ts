import { ElementRef, EventEmitter, Renderer2 } from '@angular/core';
import { AbstractControl, ControlValueAccessor, ValidationErrors, Validator } from '@angular/forms';
import { DlDateAdapter } from '../core/public-api';
import { DlDateTimeInputChange } from './dl-date-time-input-change';
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 */
import * as ɵngcc0 from '@angular/core';
export declare class DlDateTimeInputDirective<D> implements ControlValueAccessor, Validator {
    private _renderer;
    private _elementRef;
    private _dateAdapter;
    private readonly _displayFormat;
    private readonly _inputFormats;
    private _filterValidator;
    private _inputFilter;
    private _isValid;
    private _parseValidator;
    private _changed;
    private _touched;
    private _validator;
    private _onValidatorChange;
    private _value;
    /**
     * Emits when a `change` event when date/time is selected or
     * the value of the date/time picker changes.
     **/
    readonly dateChange: EventEmitter<DlDateTimeInputChange<D>>;
    /**
     * Constructs a new instance of this directive.
     * @param _renderer
     *  reference to the renderer.
     * @param _elementRef
     *  reference to this element.
     * @param _dateAdapter
     *  date adapter for the date type in the model.
     * @param _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    constructor(_renderer: Renderer2, _elementRef: ElementRef, _dateAdapter: DlDateAdapter<D>, _displayFormat: string, _inputFormats: string[]);
    /**
     * Set a function used to determine whether or not the `value` entered by the user is allowed.
     * @param inputFilterFunction
     *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
     */
    dlDateTimeInputFilter: (value: D | null) => boolean;
    /**
     * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
     **/
    /**
    * Set the value of the date/time input to a value of `D` | `undefined` | `null`;
    * @param newValue
    *  the new value of the date/time input
    */
    value: D;
    /**
     * Emit a `change` event when the value of the input changes.
     */
    _onChange(): void;
    /**
     * Format the input text using {@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     */
    _onBlur(): void;
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param value
     *   Value of the input control.
     */
    _onInput(value: string | null | undefined): void;
    /**
     * @internal
     */
    private _setElementValue;
    /**
     * @internal
     */
    registerOnChange(onChange: (value: any) => void): void;
    /**
     * @internal
     */
    registerOnTouched(onTouched: () => void): void;
    /**
     * @internal
     */
    registerOnValidatorChange(validatorOnChange: () => void): void;
    /**
     * @internal
     */
    setDisabledState(isDisabled: boolean): void;
    /**
     * @internal
     */
    validate(control: AbstractControl): ValidationErrors | null;
    /**
     * @internal
     */
    writeValue(value: D): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DlDateTimeInputDirective<any>>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DlDateTimeInputDirective<any>, "input[dlDateTimeInput]", never, {
    "dlDateTimeInputFilter": "dlDateTimeInputFilter";
}, {
    "dateChange": "dateChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLWlucHV0LmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJkbC1kYXRlLXRpbWUtaW5wdXQuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZGQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEbERhdGVBZGFwdGVyIH0gZnJvbSAnLi4vY29yZS9wdWJsaWMtYXBpJztcbmltcG9ydCB7IERsRGF0ZVRpbWVJbnB1dENoYW5nZSB9IGZyb20gJy4vZGwtZGF0ZS10aW1lLWlucHV0LWNoYW5nZSc7XG4vKipcbiAqICBUaGlzIGRpcmVjdGl2ZSBhbGxvd3MgdGhlIHVzZXIgdG8gZW50ZXIgZGF0ZXMsIHVzaW5nIHRoZSBrZXlib2FyZCwgaW50byBhbiBpbnB1dCBib3ggYW5kXG4gKiAgYW5ndWxhciB3aWxsIHRoZW4gc3RvcmUgYSBkYXRlIHZhbHVlIGluIHRoZSBtb2RlbC5cbiAqXG4gKiAgVGhlIGlucHV0IGZvcm1hdChzKSwgZGlzcGxheSBmb3JtYXQsIGFuZCBtb2RlbCBmb3JtYXQgYXJlIGluZGVwZW5kZW50IGFuZCBmdWxseSBjdXN0b21pemFibGUuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZTxEPiBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuICAgIHByaXZhdGUgX3JlbmRlcmVyO1xuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBfZGF0ZUFkYXB0ZXI7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZGlzcGxheUZvcm1hdDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pbnB1dEZvcm1hdHM7XG4gICAgcHJpdmF0ZSBfZmlsdGVyVmFsaWRhdG9yO1xuICAgIHByaXZhdGUgX2lucHV0RmlsdGVyO1xuICAgIHByaXZhdGUgX2lzVmFsaWQ7XG4gICAgcHJpdmF0ZSBfcGFyc2VWYWxpZGF0b3I7XG4gICAgcHJpdmF0ZSBfY2hhbmdlZDtcbiAgICBwcml2YXRlIF90b3VjaGVkO1xuICAgIHByaXZhdGUgX3ZhbGlkYXRvcjtcbiAgICBwcml2YXRlIF9vblZhbGlkYXRvckNoYW5nZTtcbiAgICBwcml2YXRlIF92YWx1ZTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIGEgYGNoYW5nZWAgZXZlbnQgd2hlbiBkYXRlL3RpbWUgaXMgc2VsZWN0ZWQgb3JcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIgY2hhbmdlcy5cbiAgICAgKiovXG4gICAgcmVhZG9ubHkgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPERsRGF0ZVRpbWVJbnB1dENoYW5nZTxEPj47XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKiBAcGFyYW0gX3JlbmRlcmVyXG4gICAgICogIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtIF9lbGVtZW50UmVmXG4gICAgICogIHJlZmVyZW5jZSB0byB0aGlzIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIF9kYXRlQWRhcHRlclxuICAgICAqICBkYXRlIGFkYXB0ZXIgZm9yIHRoZSBkYXRlIHR5cGUgaW4gdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSBfZGlzcGxheUZvcm1hdFxuICAgICAqICBmcm9tIGBETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVRgLCB3aGljaCBkZWZpbmVzIHRoZSBmb3JtYXQgdG8gdXNlIGZvciBhIHZhbGlkIGRhdGUvdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gX2lucHV0Rm9ybWF0c1xuICAgICAqICBmcm9tIGBETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUU2AsIHdoaWNoIGRlZmluZXMgdGhlIGlucHV0IGZvcm1hdHMgdGhhdCBhbGxvd2VkIGFzIHZhbGlkIGRhdGUvdGltZSB2YWx1ZXMuXG4gICAgICogIE5COiBtb21lbnQgaXMgYWx3YXlzIGluIHN0cmljdCBwYXJzZSBtb2RlIGZvciB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfcmVuZGVyZXI6IFJlbmRlcmVyMiwgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIF9kYXRlQWRhcHRlcjogRGxEYXRlQWRhcHRlcjxEPiwgX2Rpc3BsYXlGb3JtYXQ6IHN0cmluZywgX2lucHV0Rm9ybWF0czogc3RyaW5nW10pO1xuICAgIC8qKlxuICAgICAqIFNldCBhIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSBgdmFsdWVgIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgYWxsb3dlZC5cbiAgICAgKiBAcGFyYW0gaW5wdXRGaWx0ZXJGdW5jdGlvblxuICAgICAqICAgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgYWxsb3dlZCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZGxEYXRlVGltZUlucHV0RmlsdGVyOiAodmFsdWU6IEQgfCBudWxsKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYERgIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgaW5wdXQgb3IgYHVuZGVmaW5lZGAgfCBgbnVsbGAgaWYgbm8gdmFsdWUgaXMgc2V0LlxuICAgICAqKi9cbiAgICAvKipcbiAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBpbnB1dCB0byBhIHZhbHVlIG9mIGBEYCB8IGB1bmRlZmluZWRgIHwgYG51bGxgO1xuICAgICogQHBhcmFtIG5ld1ZhbHVlXG4gICAgKiAgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIGlucHV0XG4gICAgKi9cbiAgICB2YWx1ZTogRDtcbiAgICAvKipcbiAgICAgKiBFbWl0IGEgYGNoYW5nZWAgZXZlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGNoYW5nZXMuXG4gICAgICovXG4gICAgX29uQ2hhbmdlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRoZSBpbnB1dCB0ZXh0IHVzaW5nIHtAbGluayBETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVR9IGFuZCBtYXJrIHRoZSBjb250cm9sIGFzIHRvdWNoZWQuXG4gICAgICovXG4gICAgX29uQmx1cigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSB1c2VyIGlucHV0IGludG8gYSBwb3NzaWJseSB2YWxpZCBkYXRlLlxuICAgICAqIFRoZSBtb2RlbCB2YWx1ZSBpcyBub3Qgc2V0IGlmIHRoZSBpbnB1dCBpcyBOT1Qgb25lIG9mIHRoZSB7QGxpbmsgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFN9LlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqICAgVmFsdWUgb2YgdGhlIGlucHV0IGNvbnRyb2wuXG4gICAgICovXG4gICAgX29uSW5wdXQodmFsdWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgX3NldEVsZW1lbnRWYWx1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKG9uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKHZhbGlkYXRvck9uQ2hhbmdlOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IEQpOiB2b2lkO1xufVxuIl19