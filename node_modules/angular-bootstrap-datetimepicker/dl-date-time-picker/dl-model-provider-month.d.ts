/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import { SimpleChanges } from '@angular/core';
import { DlDateTimePickerModel } from './dl-date-time-picker-model';
import { DlModelProvider } from './dl-model-provider';
/**
 * Default implementation for the `month` view.
 */
import * as ɵngcc0 from '@angular/core';
export declare class DlMonthModelProvider implements DlModelProvider {
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    onChanges(changes: SimpleChanges): void;
    /**
     * Returns the `month` model for the specified moment in `local` time with the
     * `active` month set to the first day of the specified month.
     *
     * The `month` model represents a year (12 months) as three rows with four columns.
     *
     * The year always starts in January.
     *
     * Each cell represents midnight on the 1st day of the month.
     *
     * The `active` month will be the January of year of the specified milliseconds.
     *
     * @param milliseconds
     *  the moment in time from which the month model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    getModel(milliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the active `month` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one row `down` from the specified moment in time.
     */
    goDown(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the active `month` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the previous `month` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one row `up` from the specified moment in time.
     */
    goUp(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the `active` `month` one (1) month to the `left` of the specified moment in time.
     *
     * Moving `left` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `month` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one month to the `left` of the specified moment in time.
     */
    goLeft(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the `active` `month` one (1) month to the `right` of the specified moment in time.
     *
     * The `active` month will be `one (1) month after` the specified milliseconds.
     * This moves the `active` date one month `right` in the current `month` view.
     *
     * Moving `right` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `month` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year to the `right` of the specified moment in time.
     */
    goRight(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    pageDown(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `up` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year `up` from the specified moment in time.
     */
    pageUp(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the `active` `month` to `December` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `December 1` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `December` cell in the view as the active `month`.
     */
    goEnd(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    /**
     * Move the `active` `month` to `January` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `January 1` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `January` cell in the view as the active `month`.
     */
    goHome(fromMilliseconds: number, selectedMilliseconds: number): DlDateTimePickerModel;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DlMonthModelProvider>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<DlMonthModelProvider>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtbW9kZWwtcHJvdmlkZXItbW9udGguZC50cyIsInNvdXJjZXMiOlsiZGwtbW9kZWwtcHJvdmlkZXItbW9udGguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxSkEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IERhbGUgTG90dHMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuZGFsZWxvdHRzLmNvbVxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9kYWxlbG90dHMvYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5pbXBvcnQgeyBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEbERhdGVUaW1lUGlja2VyTW9kZWwgfSBmcm9tICcuL2RsLWRhdGUtdGltZS1waWNrZXItbW9kZWwnO1xuaW1wb3J0IHsgRGxNb2RlbFByb3ZpZGVyIH0gZnJvbSAnLi9kbC1tb2RlbC1wcm92aWRlcic7XG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBgbW9udGhgIHZpZXcuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERsTW9udGhNb2RlbFByb3ZpZGVyIGltcGxlbWVudHMgRGxNb2RlbFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBSZWNlaXZlcyBpbnB1dCBjaGFuZ2VzIGRldGVjdGVkIGJ5IEFuZ3VsYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlc1xuICAgICAqICB0aGUgaW5wdXQgY2hhbmdlcyBkZXRlY3RlZCBieSBBbmd1bGFyLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgbW9udGhgIG1vZGVsIGZvciB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiBgbG9jYWxgIHRpbWUgd2l0aCB0aGVcbiAgICAgKiBgYWN0aXZlYCBtb250aCBzZXQgdG8gdGhlIGZpcnN0IGRheSBvZiB0aGUgc3BlY2lmaWVkIG1vbnRoLlxuICAgICAqXG4gICAgICogVGhlIGBtb250aGAgbW9kZWwgcmVwcmVzZW50cyBhIHllYXIgKDEyIG1vbnRocykgYXMgdGhyZWUgcm93cyB3aXRoIGZvdXIgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIFRoZSB5ZWFyIGFsd2F5cyBzdGFydHMgaW4gSmFudWFyeS5cbiAgICAgKlxuICAgICAqIEVhY2ggY2VsbCByZXByZXNlbnRzIG1pZG5pZ2h0IG9uIHRoZSAxc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICAgKlxuICAgICAqIFRoZSBgYWN0aXZlYCBtb250aCB3aWxsIGJlIHRoZSBKYW51YXJ5IG9mIHllYXIgb2YgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWlsbGlzZWNvbmRzXG4gICAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBtb250aCBtb2RlbCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogIHRoZSBtb2RlbCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICAgKi9cbiAgICBnZXRNb2RlbChtaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbDtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBhY3RpdmUgYG1vbnRoYCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAgICpcbiAgICAgKiBNb3ZpbmcgYGRvd25gIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIG1vbnRoIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgeWVhciB0aGFuXG4gICAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgeWVhciByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgbW9udGhgIG1vZGVsIGBkb3duYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGBtb250aGAgb25lIHJvdyBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgICAqL1xuICAgIGdvRG93bihmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWw7XG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgYWN0aXZlIGBtb250aGAgb25lIHJvdyBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICAgKlxuICAgICAqIE1vdmluZyBgdXBgIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIG1vbnRoIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgeWVhciB0aGFuXG4gICAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgeWVhciByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgcHJldmlvdXMgYG1vbnRoYCBtb2RlbCBgdXBgIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYG1vbnRoYCBvbmUgcm93IGB1cGAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgICAqL1xuICAgIGdvVXAoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsO1xuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGBhY3RpdmVgIGBtb250aGAgb25lICgxKSBtb250aCB0byB0aGUgYGxlZnRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAgICpcbiAgICAgKiBNb3ZpbmcgYGxlZnRgIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIG1vbnRoIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgeWVhciB0aGFuXG4gICAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgeWVhciByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgYG1vbnRoYCBtb2RlbCB0byB0aGUgYGxlZnRgIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYG1vbnRoYCBvbmUgbW9udGggdG8gdGhlIGBsZWZ0YCBvZiB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgICAqL1xuICAgIGdvTGVmdChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWw7XG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgYGFjdGl2ZWAgYG1vbnRoYCBvbmUgKDEpIG1vbnRoIHRvIHRoZSBgcmlnaHRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAgICpcbiAgICAgKiBUaGUgYGFjdGl2ZWAgbW9udGggd2lsbCBiZSBgb25lICgxKSBtb250aCBhZnRlcmAgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAgICogVGhpcyBtb3ZlcyB0aGUgYGFjdGl2ZWAgZGF0ZSBvbmUgbW9udGggYHJpZ2h0YCBpbiB0aGUgY3VycmVudCBgbW9udGhgIHZpZXcuXG4gICAgICpcbiAgICAgKiBNb3ZpbmcgYHJpZ2h0YCBjYW4gcmVzdWx0IGluIHRoZSBgYWN0aXZlYCBtb250aCBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IHllYXIgdGhhblxuICAgICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIHllYXIgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCB5ZWFyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGBtb250aGAgbW9kZWwgdG8gdGhlIGByaWdodGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAgICogQHJldHVybnNcbiAgICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgbW9udGhgIG9uZSB5ZWFyIHRvIHRoZSBgcmlnaHRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAgICovXG4gICAgZ29SaWdodChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWw7XG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgYWN0aXZlIGBtb250aGAgb25lIHllYXIgYGRvd25gIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICAgKlxuICAgICAqIFBhZ2luZyBgZG93bmAgd2lsbCByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIG1vbnRoIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgeWVhciB0aGFuXG4gICAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AuIEFzIGEgcmVzdWx0LCB0aGUgeWVhciByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgbW9udGhgIG1vZGVsIHBhZ2UgYGRvd25gIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYG1vbnRoYCBvbmUgeWVhciBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgICAqL1xuICAgIHBhZ2VEb3duKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbDtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBhY3RpdmUgYG1vbnRoYCBvbmUgeWVhciBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgICAqXG4gICAgICogUGFnaW5nIGB1cGAgd2lsbCByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIG1vbnRoIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgeWVhciB0aGFuXG4gICAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AuIEFzIGEgcmVzdWx0LCB0aGUgeWVhciByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgbW9udGhgIG1vZGVsIHBhZ2UgYHVwYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGBtb250aGAgb25lIHllYXIgYHVwYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAgICovXG4gICAgcGFnZVVwKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbDtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgbW9udGhgIHRvIGBEZWNlbWJlcmAgb2YgdGhlIGN1cnJlbnQgeWVhci5cbiAgICAgKlxuICAgICAqIFRoZSB2aWV3IG9yIHRpbWUgcmFuZ2Ugd2lsbCBub3QgY2hhbmdlIHVubGVzcyB0aGUgYGZyb21NaWxsaXNlY29uZHNgIHZhbHVlXG4gICAgICogaXMgaW4gYSBkaWZmZXJlbnQgeWVhciB0aGFuIHRoZSBkaXNwbGF5ZWQgZGVjYWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggYERlY2VtYmVyIDFgIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAgICogQHJldHVybnNcbiAgICAgKiAgYSBtb2RlbCB3aXRoIHRoZSBgRGVjZW1iZXJgIGNlbGwgaW4gdGhlIHZpZXcgYXMgdGhlIGFjdGl2ZSBgbW9udGhgLlxuICAgICAqL1xuICAgIGdvRW5kKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbDtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgbW9udGhgIHRvIGBKYW51YXJ5YCBvZiB0aGUgY3VycmVudCB5ZWFyLlxuICAgICAqXG4gICAgICogVGhlIHZpZXcgb3IgdGltZSByYW5nZSB3aWxsIG5vdCBjaGFuZ2UgdW5sZXNzIHRoZSBgZnJvbU1pbGxpc2Vjb25kc2AgdmFsdWVcbiAgICAgKiBpcyBpbiBhIGRpZmZlcmVudCB5ZWFyIHRoYW4gdGhlIGRpc3BsYXllZCBkZWNhZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCBgSmFudWFyeSAxYCB3aWxsIGJlIGNhbGN1bGF0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogIGEgbW9kZWwgd2l0aCB0aGUgYEphbnVhcnlgIGNlbGwgaW4gdGhlIHZpZXcgYXMgdGhlIGFjdGl2ZSBgbW9udGhgLlxuICAgICAqL1xuICAgIGdvSG9tZShmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWw7XG59XG4iXX0=